# Chapter01 데이터 타입

## 1. 데이터 타입의 종류

1. **기본형** 원시형(Primitive type)
   숫자, 문자열, 불리언, null, undefined, Symbol(ES6)  

2. **참조형** Reference type
   객체(Object), 배열(Array), 함수,(Function) 날짜(D), 정규표현식(RegEXP)
   객체의 하위분류(ES6): Map, WeakMap, Set, WeakSet

* **기본형과 참조형을 구분하는 방법**
: 기본형은 **값이 담긴 주솟값**을 바로 복제
: 참조형은 **값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값**을 복제  

## 2. 데이터 타입에 관한 배경지식
### 1) 메모리와 데이터
- 메모리는 매우 많은 비트로 구성
- 각 비트는 고유한 식별자를 통해 위치 확인이 가능
- 비트가 앵간히 많아야지, 하지만 비트 단위로 위치를 확인하는 것은 비효율적이다.
- 그렇다면 비티를 몇 개씩 묶어 하나의 단위로 표현한다면?
<br>
- **장점**: 검색시간을 줄이고, 표현할 수 있는 데이터의 개수가 늘어남 
❓검색 시간이 줄어든다?: ex) 10000개의 비트 1개씩 검색 만 번 검색, 10개씩 묶으면 천 번만 검색하니까?
❓표현할 수 있는 데이터의 개수가 늘어난다?: 비교 기준이 묶음 당인가? 1비트 표현 가지 수 2, 2비트씩 묶으면 *2배 증가?
  
- **단점**: 낭비되는 비트가 생긴다. c/c++/java등의 정적 타입 언어는 그래서 메모리 낭비를 최소화하기 위해 메모리 영역을 2/4 바이트로 나누어 정해놓음.
<br>
- ex) 2byte= 16bit= 2^16 = 65536, 65,536개의 값 표현 가능
  -32,768~ +32,767  숫자 허용 (0포함)
-지금은 과거보다 메모리가 월등히 커저, 자바스크립트는 상대적으로 메모리 관리에 대한 압박이 자유로움. 숫자의 경우 8바이트를 확보함.
- 
- 모든 데이터는 (바이트 단위의 식별자), (메모리 주솟값) 을 통해 서로 구분하고 연결할 수 있다.
<br>

### 2) 식별자와 변수
- 변수(Variable)과 식별자(Identifier) 구분하기
- 변수: 데이터, 변경가능한 데이터가 담길 수 있는 공간, 그릇
- 식별자: 어떤 데이터를 식별하는 데 사용하는 이름, 변수명

### 3) 변수 선언과 데이터 할당
- 변수 영역에 값을 직접 대입하지 않고 굳이 데이터 영역에 값을 저장하는 이유는 뭘까?
- 이유1: 데이터 변환을 자유롭게 할 수 있음 
  그럼, **메모리를 효율적으로 관리**할 수 있기 때문
- 만약, 데이터가 변하게 된다면 '확보한 공간을 변환된 데이터 크기에 맞게 늘리는 작업이 발생.
- 하지만 중간에 있는 데이터를 늘려야 한다면? 해당 공간보다 뒤에 저장된 데이터들을 전부 뒤로 옮기고, 이동시킨 주소를 각 식별자에 다시 연결하는 작업이 발생. 오히려 컴퓨터의 연산이 더욱 많아짐. 
- 최적은 변수와 데이터를 별도의 공간에 나누어 저장하는 것
  <br>
- 이유2: **중복된 데이터에 대한 처리 효율이 높아짐**
- ex) 500개의 변수를 생서해서 모든 변수에 숫자 5를 할당하려고 할 때
- 8바이트 * 500개 = 4000바이트가 소모, 그대신 5를 별도의 공간에 저장하고 해당 주솟값을 이용한다면, 주소공간의 크기 2바이트 * 500개 + 8바이트(숫자 5) 로 총 1008바이트만 이용하면 됌. 

### 4) 기본형 데이터와 참조형 데이터

#### 불변값
    변수와 상수를 구분 짓는 것은?
    -> '변수 영역' 메모리를 변경할 수 있는가
<br>

    '불변성'여부를 구분 짓는 것은?
    -> '데이터 영역' 메모리를 변경할 수 있는가
    -> 즉, 데이터를 바꾸지 않고 변경함으로써 값을 변화시킨다면 그건 불변성이다.
<br>

- 기본형 데이터는 모두 불변 값이다.
```
var a ='abc'
a= a+'def'
```
'abc'가 'abcdef'로 바뀌는 것이 아니라 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장하는 것이다. 따라서 기존에 '데이터 영역' 메모리에 저장된 'abc'를 변경하는 것이 아니기 때문에 불변 값이라고 한다. 
- 변경은 새로 만드는 동작을 통해서만 이뤄진다. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 이상 영원히 변하지 않는다.

#### 가변값

- 기본형 데이터와의 차이는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다는 점이다. 
- 객체가 별도로 할애한 영역은 변수 영역일 뿐 '데이터 영역'은 기존의 메모리 공간을 그대로 활용하고 있다. 
- 바로 이 부분 때문에 참조형 데이터는 불변하지 않다라고 한다.
- (rough하게 말하면 원본이 바뀔 수도 있는 값)
```
var obj1 = {
    a:1,
    b:'bbb'
}
obj1.a=2
```
- page 12 그림 1-7 참고
- 객체의 내부 값, 객의 변수 영역만 값이 변한다. 
  
<br>
**가비지 컬렉터**

- 참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 된다. 
- 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때 마다 자동으로 수거대상들을 수거한다.
- 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.

#### 변수 복사 비교
- 기본형과 참조형의 복사 이후 값을 변경했을 때의 차이점
  : 기본형 - 변수 영역의 주솟값이 달라진다.
  : 참조형 - 변수 영역의 주소값은 변하지 않고, 객체의 변수 영역의 주솟값이 달라진다.
- 이는 아주 중요한 점을 시사한다. 객체의 주솟값은 그대로 쓰기 때문에 새로운 객체가 할당되지 않으면 원본과 사본의 프로퍼티는 동일하게 변하기 때문이다.
- 반면 새로운 객체를 할당하면 변수 영역의 값이 달라진다
- 즉, 참조형 데이터가 가변값이라고 하는 경우는 참조형 데이터 자체를 변경할 경우가 아니라, 그 내부의 프로퍼티를 변경할 때를 말하는 것이다.
  
### 불변객체
- 참조형 데이터의 **가변**은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립한다.
- 데이터 자체를 변경하고자 하면, 새로운 데이터를 할당하고자 하면, 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않는다. 
- 따라서 내부 프로퍼티 변경할 필요가 있을 때 마다 매번 새로운 객체를 만들어 재할당한다면, 그 객체 역시 불변성을 확보할 수 있을 것이다. 
- 불변객체가 필요한 상황은?
  -> 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않을 때 필요하다!

  <br>
- 어떤 객체를 복사할 대 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터롤 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사, 참조형 데이터일 때는 다시 그내부의 프로퍼티를 복사해야한다.
- 프로퍼티 내부에 참조형 데이터가 있을 때마다 재귀저긍로 수행해야 비로소 깊은 복사가 된다.

**간단하게 깊은 복사를 처리할 수 있는 법**
- 객체를 JSON문법으로 표현된 문자열로 전환했다가ㅡ 다시 JSON객체로 바꾸는 것
- httpRequest로 받은 데이털를 저장한 객체를 복사할 때 순수한 정보만 다룰 때 활용하기 좋다
- 메서드, 숨겨진 프로퍼티(__proto_), getter, setter 프로퍼티는 무시된다.

## Undefined와 null

- 배열은 무조건 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각 공간에 인덱스에 값을 지정할 것이라고 생각하기 쉽다
- 실제로는 객체와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 동작을 한다.
- undefined와 null을 구분하려면, 비어있는 값을 명시적으로 넣을 때는 null을 자바스크립트 엔진이 값을 할당할 수 없거나 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 할당하는 것으로 한다.



---
**새롭게 알았던 점**
1) 기본형, 참조형, 불변성, 가변성, 얕은복사, 깊은복사
2) 

**퀴즈**

 ``` var object1 = {'a':['b','c',['d','e',['f','g']]]}```  를 복사하려면 재귀함수가 몇 번필요할까? 

```
var copyObectDeep = function(target) {
    var result = {}
    if (typeof target === 'object' && target !== null){
        for(var prop in target){
            result[prop] = copyObectDeep(target[prop])       
         }   
    }else{
        result = target
    }
    return result
}
var object2 = copyObjectDeep(object1)
```
---
--> 10번, 배열의 요소도 각각 실행됨.

(1) object1

(2) ['b','c',['d','e',['f','g']]]

(3) 'b' -> (2)의 prop은 배열의 인데스이기 때문에, target[0]='b'가 됌

(4) 'c'

(5) ['d','e',['f','g']]

(6) 'd'

(7) 'e'

(8) ['f','g']

(9) 'f'

(10) 'g'


![image](https://user-images.githubusercontent.com/76730867/137319809-0f2fb0a3-ceec-4c69-9fa0-11cee3b14ea9.png)

