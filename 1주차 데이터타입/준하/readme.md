# Chapter01 데이터 타입

## 1. 데이터 타입의 종류

1. **기본형**
   - 원시형(Primitive type)
   - 숫자, 문자열, 불리언, null, undefined, Symbol(ES6)  

2. **참조형** 
   - Reference type
   - 객체(Object), 배열(Array), 함수,(Function) 날짜(Date), 정규표현식(RegEXP)
   - 객체의 하위분류(ES6): Map, WeakMap, Set, WeakSet
   - ![](https://user-images.githubusercontent.com/76730867/148520248-06efef24-9586-4380-9f6a-d1e862fabd00.png)

#### 기본형과 참조형을 구분하는 방법

- 기본형은 **값이 담긴 주솟값**을 복제한다.
- 참조형은 값이 담긴 **주솟값들로 이루어진 묶음을 가리키는 주솟값**을 복제한다.  

## 2. 데이터 타입에 관한 배경지식

### 1) 메모리와 데이터

- 각 비트는 고유한 식별자를 통해 위치를 확인한다. 하지만 메모리는 매우 많은 비트로 구성되어 있기 때문에 비트 단위로 위치를 확인하는 것은 비효율적이다.

#### Byte: 비트를 묶어 하나의 단위로 표현해보자

- **장점**
  1. 검색 시간이 줄어든다.
      - 10000개의 비트를 1개씩 검색하면 만 번을 검색해야 하지만, 8개씩 묶으면 검색 횟수가 8배 낮아진다.
  2. 표현할 수 있는 데이터의 개수가 늘어난다.
     - 1비트 표현 가지 수는 2개 뿐이지만, 2비트씩 묶으면 2배씩 증가한다.

- **단점**
  - 낭비되는 비트가 생긴다. 그렇기에 C, C++, JAVA등의 정적 타입 언어는 메모리 낭비를 최소화하기 위해 메모리 영역을 특정 바이트로 나누어 정해놓는다.
  - ex) 2byte= 16bit= 2^16 = 65536, 65,536개의 값을 표현할 수 있다.32,768~ +32,767  숫자를 허용한다. (0포함)

* 지금은 과거보다 메모리가 월등히 커저, 자바스크립트는 상대적으로 메모리 관리에 대한 압박이 자유로우며, 숫자의 경우 8바이트를 확보한다.
* 모든 데이터는 바이트 단위의 식별자, 메모리 주솟값을 통해 서로 구분하고 연결할 수 있다.


### 2) 변수와 식별자

- 변수(Variable): 변경 가능한 데이터가 담길 수 있는 공간, 그릇
- 식별자(Identifier): 어떤 데이터를 식별하는 데 사용하는 이름, 변수명

### 3) 변수 선언과 데이터 할당

- 변수 영역에 값을 직접 대입하지 않고 굳이 데이터 영역에 값을 저장하는 이유는 뭘까? 

#### 데이터 영역에 값을 저장하면 **메모리를 효율적으로 관리**할 수 있다.

##### 1) 데이터 변환을 자유롭게 할 수 있다.

- 데이터를 추가해야하는 상황이 발생하면, '확보한 공간을 변환된 데이터 크기에 맞게 늘리는 작업이 발생한다.
- 중간에 있는 데이터를 늘리기 위해 해당 공간보다 뒤에 저장된 데이터들을 전부 뒤로 옮기고, 이동시킨 주소를 각 식별자에 다시 연결하는 작업이 발생하여, 컴퓨터의 연산이 더욱 많아지게 된다.
- 따라서 최적은 변수와 데이터를 별도의 공간에 나누어 저장하는 것이다.

##### 2) 중복된 데이터에 대한 처리 효율이 높아진다.
- 예를 들어, 500개의 변수를 생성해서 모든 변수에 숫자 5를 할당할 때, 8바이트 * 500개 = 4000바이트가 소모된다.
- 그대신 5를 별도의 공간에 저장하고 해당 주솟값을 이용한다면, 주소공간의 크기 2바이트 * 500개 + 8바이트(숫자 5) 로 총 1008바이트만 이용하면 메모리를 효율적으로 사용할 수 있게 된다.

## 3. 기본형 데이터와 참조형 데이터

#### 1) 불변값

- 변수와 상수를 구분 짓는 것은? 
    - **'변수 영역' 메모리**를 변경할 수 있는가

```js
const cons = 1
let vari = 1

cons = 2 //  Assignment to constant variable.
vari = 2 // 
```

- 기본형 데이터 타입의 변수는 값을 재할당할 때 메모리에 저장된 데이터가 실제로 바뀌는 것처럼 보인다.
- 하지만 메모리에 저장된 데이터는 건드리지 않고, 새로운 데이터를 만들어 주솟값만 재할당하는 프로세스를 따르기 때문에 기본형 데이터 타입의 값은 불변값이라고 부른다. 

##### 기본형 데이터는 모두 불변값이다.

```js
var a = 'abc'
a = a +' def'
```

- 'abc'가 'def'로 바뀌는 것이 아니라, 새로운 문자열 'def'를 만들어 그 주소를 변수 a에 저장된다. 따라서 **기존에 '데이터 영역' 메모리에 저장된 'abc'를 변경하는 것이 아니기 때문에 불변값**이라고 한다. 
- 🎈변경은 새로 만드는 동작을 통해서만 이뤄진다. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 이상 영원히 변하지 않는다.
<br>
- 그렇다면 '불변성'여부를 구분 짓는 것은?
  - **'데이터 영역' 메모리**를 변경할 수 있는가이다.

#### 2) 가변값

- 기본형 데이터 타입과 참조형 데이터 타입의 차이는 **객체의 변수 영역, 즉 프로퍼티가 별도로 존재**한다는 점이다. 
- 참조형 데이터 타입도 값은 '데이터 영역'에 저장하며 기존의 메모리 공간을 그대로 활용하고 있지만, **객체가 별도로 할애한 영역(프로퍼티)은 변수 영역이기 때문에 원하는 만큼 값을 바꾸고 수정할 수 있다.** 바로 이부분 때문에 참조형 데이터의 값은 가변값이라고 한다.

```js
var obj1 = {
    a:1,
    b:'aaa'
}
obj1.a = 'aaa'
```

![](https://user-images.githubusercontent.com/76730867/148539601-27aab07e-bfba-42f0-b5a6-decf7326bbe9.png)

- obj1의 데이터는 그대로(@5002)이지만, 그 안의 데이터, 프로퍼티 a는(@5003 → @5004) 새롭게 변경되었다. 바로 이 점이 데이터 할당에 의해 **가변적**으로 변경된 것처럼 보이는 점이다. 

##### 데이터의 가변성/불변성을 구분하는 기준이 데이터 영역이 되는 이유
1. 객체의 값은 (객체 변수 영역을 가르키는 주솟값들의 묶음)의 주솟값이다 (@5002).
2. 객체의 변수 영역의 값이 바뀔때마다, 데이터 영역안에 있는 **이 묶음의 주솟값은 바뀌진 않지만, 갖고있는 값은 바뀐다.**
3. 따라서 객체의 변수 영역의 값이 달라지면, 묶음의 주솟값을 갖고 있는 객체도 값이 바뀌는 현상이 나타나게 된다.

##### 참고) 가비지 컬렉터

- 참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 된다. 
- 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때 마다 자동으로 수거대상들을 수거한다.
- 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.

#### 변수 복사 비교

- 기본형과 참조형의 복사 이후 값을 변경했을 때의 차이점
  - 기본형 - 변수 영역의 주솟값이 달라진다.
  - 참조형 - 변수 영역의 주소값은 변하지 않고, 객체의 변수 영역의 주솟값이 달라진다.
  객체의 주솟값은 그대로 쓰기 때문에 새로운 객체가 할당되지 않으면 원본과 사본의 프로퍼티는 동일하게 변한다.
- 반면, 새로운 객체를 할당하면 변수 영역의 값이 달라진다
- 즉, 참조형 데이터가 가변값이라고 하는 경우는 참조형 데이터 자체를 변경할 경우가 아니라, 그 내부의 프로퍼티를 변경할 때를 말하는 것이다.
  
## 4. 불변객체

### 1) 객체에 가변성에 따른 문제
- 복제한 객체의 내부 프로퍼티를 변경했을 때 원본 객체의 데이터도 변경된다.

```js
var monster = {
  type:'greek',
  power:'0'
}

var minotaur = monster // 객체 자체를 복제
minotaur.power = 100

console.log(minotaur.power) // 100
console.log(monster.power) // 100
// original data is changed because of replicted object
```

- 참조형 데이터의 **가변**은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립한다.
- 참조형 데이터 자체를 변경하고자 하면 새로운 데이터를 할당하므로 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않는다. 
- 따라서 **내부 프로퍼티를 변경할 때 마다 매번 새로운 객체를 만들어 재할당한다면, 그 객체 역시 불변성을 확보**할 수 있을 것이다. 
- 불변객체는 값으로 전달받은 객체에 변경을 가하더라도 원본 객체가 훼손되지 않게한다.
- 어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터롤 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사, 참조형 데이터일 때는 다시 그 내부의 프로퍼티를 복사해야한다.
- 프로퍼티 내부에 참조형 데이터가 있을 때마다 재귀적으로 수행하는 것을 **깊은 복사**라고 한다.

### 2) 원본 객체를 훼손하지 않는 방법

- `minotaur`객체를 `monster`객체로 복제하지 않고, 객체 리터럴 `{}`를 이용하여 생성한다.

```js
var monster = {
  type:'greek',
  power:'0'
}

var minotaur = {
  type:monster.type,
  power:100
}

console.log(minotaur.power) // 100
console.log(monster.power) // 0
```

### 3) 얕은 복사

- 객체의 프로퍼티가 많을 수록 일일이 하드코딩하면 귀찮다.
- 모든 프로퍼티를 복사하는 얕은 복사 함수를 만들어보자.

```js
var copyObject = function(target) {
  var result = {}
  for (var prop in target){
    result[prop] = target[prop];
  }
  return result
}
```

```js
var monster = {
  type:'greek',
  power:'0'
}

var minotaur = copyObject(monster)
minotaur.power = 100

console.log(minotaur.power) // 100
console.log(monster.power) // 0
console.log(minotaur === monster) // false
```
- `monster` 객체 내부의 변경이 필요할 때 `copyObject`함수를 사용하기로 약속한다면, `monster` 객체는 불변 객체라고 부를 수 있다.
- 하지만 약속은 깨지기 쉽다. 그렇기에 `immutable.js`, `baobab.js`등의 라이브러리를 사용하여 불변성을 지닌 별도의 데이터 타입과 메서드를 이용하기도 한다.

### 4) 깊은 복사

- 얕은 복사는 바로 아래 단계의 값만 복사하는 방법이고, 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법이다. 
- 어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만, 참조형 데이터라면 다시 그 내부의 프로퍼티를 복사해야한다.

```js
var monster = {
  type:'greek',
  skills:['bite','rush','rage']
}

var minotaur = copyObject(monster)
minotaur.skills=copyObject(monster.skills)
```

#### (1) 재귀함수를 활용한 깊은 복사

- 매개변수가 object면 prop의 key를 생성하고, 매개변수가 object가 아니면 그대로 다시 반환하여 value를 할당한다.

```js
var copyObjectDeep = function (target) {
  var result = {}
  if (typeof target ==='object' && target!==null){
    for(var prop in target){
      result[prop] = copyObjectDeep(target[prop])
    }
  } else{
    return target
  }
  return result
}
```


#### (2) JSON을 활용한 깊은 복사

- 객체를 문자열로 전환했다가 다시 JSON객체로 바꾸는 방법이다.
- httpRequest로 받은 데이터를 저장한 객체를 복사할 때 순수한 정보만 다룰 때 활용하기 좋다

```js
var copyObjectViaJSON = function(target){
  return JSON.parse(JSON.stringify(target))
}
```

- array 타입의 데이터도 객체 타입으로 바뀌는 (1)번 방법과 달리, JSON을 활용한 방법은 array 그대로 복사된다.

## 5. `undefined` & `null`

### 1.`undefined`

- `undefined`는 자바스크립트 엔진이 사용자가 값을 넣었으리라고 예상했지만 그렇지 않은 경우에 할당해주는 값이다.

##### (1) 값을 대입하지 않은 변수

- 식별자가 데이터 영역의 메모리 주소를 지정하지 않은 경우

```js
var a;
console.log(a) // undefined
```

##### (2) 객체 내부의 존재하지 않은 프로퍼티

- 참고: 객체 내부의 존재하지 않은 **메소드**는 호출하면 오류가 발생한다.

```js
var obj = {
  a : 1
}
console.log(obj.b) // undefined
```

##### (3) return문이 없는 함수의 실행 결과

```js
var func = function() {};
var c = func();
console.log(c) // undefined
```

#### 2) empty

- 비어있는 배열의 요소는 `undefined`, 대신 `empty`로 할당한다.

```js
var arr1 = []
arr1.length = 3

var arr2 = new Array(3)

console.log(arr1) // [empty * 3]
console.log(arr2) // [empty * 3]
```

##### empty는 배열 메서드의 순회대상에서 제외된다.
- `empty`인 요소는 `비어있는 요소`라는 뜻을 내포하고 있어 배열 메서드의 순회대상에서 제외된다.
- 따라서 비어있는 요소에 `undefined`를 할당하면, 값이 들어가 있는 것으로 간주하여 배열 메서드의 순회대상에 포함된다.

```js
var arr1 = [undefined, 999] // [undefined, 999]
var arr2 = [,, 999] // [empty, 999]

arr1.forEach((v,i)=>console.log(v,i)) // undefined,0 / 999,1
arr2.forEach((v,i)=>console.log(v,i)) // (생략) / 999, 2
// `empty`인 요소는 인덱스는 갖고 있다.

arr1.map((v,i)=> v+i) // [Nan, 1000] (undefined+1 = NAN)
arr2.map((v,i)=> v+i) // [empty × 2, 1001]

[,undefined,null,0,false,].filter((v)=>!v) // [undefined,null,0,false]
// filter 메서드는 반환값이 true인 경우에만 그 배열의 요소를 반환한다.
```

- 존재하지 않는 프로퍼티에 순회할 수 없는 이유는 배열도 객체와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 동작을 한다.
- 즉, **값이 지정되지 않은 인덱스는 아직은 존재하지 않은 프로퍼티**이다.
- 여기서 `undefined`는 비록 **비어있음**을 의미하긴 하지만 하나의 값으로 동작하기 때문에 이때의 프로퍼티나 배열의 요소는 고유의 키값(인덱스)가 실존하게 되므로 순회할 수 있다.


### 2.`null`

- 비어있는 값을 명시적으로 넣다는 것을 강조하기 위해 사용한다.
- 본래의 의미에 따라 사용자가 없음을 표현하기 위해선 `undefined`대신 `null`을 사용해야한다.
- `typeof undefined` = `object`이기 때문에 `null`값을 체크하기 위해선 `typeof`를 사용하지 않고, `===` 일치연산자를 사용한다.


## 6. 정리

- 변수는 변경 가능한 데이터가 담길 수 있는 공간이고, 식별자는 그 변수의 이름을 말한다.
- 변수를 선언하면 컴퓨터는 메모리의 빈 공간에 식별자를 저장하고, 자동으로 `undefined`를 할당한다. 
  1) 변수에 기본형 데이터를 할당하려고 하면 별도의 공간에 데이터를 저장하고, 그 공간의 주소를 변수의 값 영역에 할당한다.
  2) 참조형 데이터를 할당하는 경우는 내부 프로퍼티들이 들어갈 변수 영역을 별도로 확보 후 그 주소를 변수에 연결한다. 그 다음 변수 영역에 각 프로퍼티의 식별자를 저장하고, 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭한다. 
- 할당 과정에서 기본형과 참조형의 차이의 이유는 참조형 데이터가 여러개의 프로퍼티를 모은 **그룹**이기 때문이다.
---

## 퀴즈

1. ``` var object1 = {'a':['b','c',['d','e',['f','g']]]}```  를 복사하려면 재귀함수가 몇 번필요할까? 

```js
var copyObectDeep = function(target) {
    var result = {}
    if (typeof target === 'object' && target !== null){
        for(var prop in target){
            result[prop] = copyObectDeep(target[prop])       
         }   
    }else{
        result = target
    }
    return result
}
var object2 = copyObjectDeep(object1)
```

---

답: 10번

- 배열의 요소는 key를 인덱스로 갖기 때문에 참고하라.
1. `copyObjectDeep(object1) `: object1
2. `copyObjectDeep(object1[0])`:['a','b',['d','e',['f','g']]]
3. `copyObjectDeep(object1[0][0])`: 'b'
4. `copyObjectDeep(object1[0][1])`: 'c'
5. `copyObjectDeep(object1[0][2])`: ['d','e',['f','g']]
6. `copyObjectDeep(object1[0][2][0])`: 'd'
7. `copyObjectDeep(object1[0][2][1])`: 'e'
8. `copyObjectDeep(object1[0][2][2])`: ['f','g']
9. `copyObjectDeep(object1[0][2][2][0])`: 'f'
10. `copyObjectDeep(object1[0][2][2][1])`: 'g'


![image](https://user-images.githubusercontent.com/76730867/137319809-0f2fb0a3-ceec-4c69-9fa0-11cee3b14ea9.png)

