# Chapter01 데이터 타입

## 1. 데이터 타입의 종류

1. **기본형**
   - 원시형(Primitive type)
   - 숫자, 문자열, 불리언, null, undefined, Symbol(ES6)  

2. **참조형** 
   - Reference type
   - 객체(Object), 배열(Array), 함수,(Function) 날짜(D), 정규표현식(RegEXP)
   - 객체의 하위분류(ES6): Map, WeakMap, Set, WeakSet
   - ![](https://user-images.githubusercontent.com/76730867/148520248-06efef24-9586-4380-9f6a-d1e862fabd00.png)

#### 기본형과 참조형을 구분하는 방법

- 기본형은 **값이 담긴 주솟값**을 복제한다.
- 참조형은 값이 담긴 **주솟값들로 이루어진 묶음을 가리키는 주솟값**을 복제한다.  

## 2. 데이터 타입에 관한 배경지식

### 1) 메모리와 데이터

- 각 비트는 고유한 식별자를 통해 위치를 확인한다. 하지만 메모리는 매우 많은 비트로 구성되어 있기 때문에, 비트 단위로 위치를 확인하는 것은 비효율적이다.

#### 비트를 몇 개씩 묶어 하나의 단위로 표현할 경우

- **장점**: 검색시간을 줄일 수 있고, 표현할 수 있는 데이터의 개수가 늘어난다.
  - ❓: 검색 시간이 줄어든다: ex) 10000개의 비트 1개씩 검색 만 번 검색, 8개씩 묶으면 검색 횟수가 8배 낮아진다.
  - ❓표현할 수 있는 데이터의 개수가 늘어난다: 1비트 표현 가지 수 2, 2비트씩 묶으면 2배씩 증가한다.

- **단점**: 낭비되는 비트가 생긴다. c/c++/java등의 정적 타입 언어는 그래서 메모리 낭비를 최소화하기 위해 메모리 영역을 2/4 바이트로 나누어 정해놓는다.
  - ex) 2byte= 16bit= 2^16 = 65536, 65,536개의 값을 표현할 수 있다.32,768~ +32,767  숫자를 허용한다. (0포함)

* 지금은 과거보다 메모리가 월등히 커저, 자바스크립트는 상대적으로 메모리 관리에 대한 압박이 자유로움. 숫자의 경우 8바이트를 확보함.
* 모든 데이터는 (바이트 단위의 식별자), (메모리 주솟값) 을 통해 서로 구분하고 연결할 수 있다.


### 2) 식별자와 변수
- 변수(Variable)과 식별자(Identifier) 구분하기
- 변수: 변경 가능한 데이터가 담길 수 있는 공간, 그릇
- 식별자: 어떤 데이터를 식별하는 데 사용하는 이름, 변수명

### 3) 변수 선언과 데이터 할당
- 변수 영역에 값을 직접 대입하지 않고 굳이 데이터 영역에 값을 저장하는 이유는 뭘까? 

#### **메모리를 효율적으로 관리**할 수 있기 때문이다.

##### 1) 데이터 변환을 자유롭게 할 수 있다.
- 만약, 데이터가 변하게 된다면 '확보한 공간을 변환된 데이터 크기에 맞게 늘리는 작업이 발생.
- 하지만 중간에 있는 데이터를 늘려야 한다면? 해당 공간보다 뒤에 저장된 데이터들을 전부 뒤로 옮기고, 이동시킨 주소를 각 식별자에 다시 연결하는 작업이 발생. 오히려 컴퓨터의 연산이 더욱 많아짐. 
- 최적은 변수와 데이터를 별도의 공간에 나누어 저장하는 것

##### 2) 중복된 데이터에 대한 처리 효율이 높아진다.
- ex) 500개의 변수를 생서해서 모든 변수에 숫자 5를 할당하려고 할 때
- 8바이트 * 500개 = 4000바이트가 소모, 그대신 5를 별도의 공간에 저장하고 해당 주솟값을 이용한다면, 주소공간의 크기 2바이트 * 500개 + 8바이트(숫자 5) 로 총 1008바이트만 이용하면 됌. 

### 3. 기본형 데이터와 참조형 데이터

#### 1) 불변값

1. 변수와 상수를 구분 짓는 것은? 
    -> **'변수 영역' 메모리**를 변경할 수 있는가

```js
const cons = 1
let vari = 1

const = 2 //  Assignment to constant variable.
vari = 2 // 
```

1. '불변성'여부를 구분 짓는 것은?
    -> **'데이터 영역' 메모리**를 변경할 수 있는가
    -> 메모리에 저장된 데이터가 바뀌는 것이 아니라, 새로 할당하는 과정에서 바뀌는 것처럼 보인다. 메모리에 저장된 데이터들이 실제로 바뀐 것이 아니기 때문에 **불변성**이라고 부를 수 있는 것이다.

##### 기본형 데이터는 모두 불변값이다.

```js
var a = 'abc'
a = a +' def'
```

- 'abc'가 'def'로 바뀌는 것이 아니라, 새로운 문자열 'def'를 만들어 그 주소를 변수 a에 저장된다. 따라서 **기존에 '데이터 영역' 메모리에 저장된 'abc'를 변경하는 것이 아니기 때문에 불변값**이라고 한다. 
- 🎈변경은 새로 만드는 동작을 통해서만 이뤄진다. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 이상 영원히 변하지 않는다.

#### 2) 가변값

- 기본형 데이터와의 차이는 객체의 변수 영역, 프로퍼티가 별도로 존재한다는 점이다. 
- 객체가 별도로 할애한 영역(프로퍼티)은 변수 영역일 뿐 '데이터 영역'은 기존의 메모리 공간을 그대로 활용하고 있다. 바로 이 부분 때문에 참조형 데이터는 불변하지 않다라고 한다.

```js
var obj1 = {
    a:1,
    b:'aaa'
}
obj1.a=2
```

![](https://user-images.githubusercontent.com/76730867/148539601-27aab07e-bfba-42f0-b5a6-decf7326bbe9.png)

- obj1.a에 obj1.b와 같은 데이터를 재할당하였습니다. 이때 a는 기본형 데이터 할당과 동일하게 데이터 영역에서 할당할 데이터가 있는지 찾아보고 해당 주소값을 할당합니다. 하지만 변하지 않은 것이 있습니다. 바로 obj1에 할당된 데이터 주소값입니다. obj1의 데이터는 그대로이고 그 안의 데이터는 새롭게 변경되었습니다. 결과적으로 obj1은 그 속의 데이터가 변경된 것처럼 보입니다. 데이터 할당에 의해 "가변"적으로 변경된 것처럼 보입니다. 흔히 데이터의 가변성/불변성을 구분하는 기준이 데이터 영역이 되는 것입니다.

##### 참고) 가비지 컬렉터

- 참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 된다. 
- 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때 마다 자동으로 수거대상들을 수거한다.
- 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.

#### 변수 복사 비교

- 기본형과 참조형의 복사 이후 값을 변경했을 때의 차이점

  : 기본형 - 변수 영역의 주솟값이 달라진다.
  : 참조형 - 변수 영역의 주소값은 변하지 않고, 객체의 변수 영역의 주솟값이 달라진다.
- 이는 아주 중요한 점을 시사한다. 객체의 주솟값은 그대로 쓰기 때문에 새로운 객체가 할당되지 않으면 원본과 사본의 프로퍼티는 동일하게 변하기 때문이다.
- 반면 새로운 객체를 할당하면 변수 영역의 값이 달라진다
- 즉, 참조형 데이터가 가변값이라고 하는 경우는 참조형 데이터 자체를 변경할 경우가 아니라, 그 내부의 프로퍼티를 변경할 때를 말하는 것이다.
  
### 불변객체
- 참조형 데이터의 **가변**은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립한다.
- 데이터 자체를 변경하고자 하면, 새로운 데이터를 할당하고자 하면, 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않는다. 
- 따라서 내부 프로퍼티 변경할 필요가 있을 때 마다 매번 새로운 객체를 만들어 재할당한다면, 그 객체 역시 불변성을 확보할 수 있을 것이다. 
- 불변객체가 필요한 상황은?
  -> 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않을 때 필요하다!

  <br>
- 어떤 객체를 복사할 대 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터롤 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사, 참조형 데이터일 때는 다시 그내부의 프로퍼티를 복사해야한다.
- 프로퍼티 내부에 참조형 데이터가 있을 때마다 재귀저긍로 수행해야 비로소 깊은 복사가 된다.

**간단하게 깊은 복사를 처리할 수 있는 법**
- 객체를 JSON문법으로 표현된 문자열로 전환했다가ㅡ 다시 JSON객체로 바꾸는 것
- httpRequest로 받은 데이털를 저장한 객체를 복사할 때 순수한 정보만 다룰 때 활용하기 좋다
- 메서드, 숨겨진 프로퍼티(__proto_), getter, setter 프로퍼티는 무시된다.

## Undefined와 null

- 배열은 무조건 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각 공간에 인덱스에 값을 지정할 것이라고 생각하기 쉽다
- 실제로는 객체와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 동작을 한다.
- undefined와 null을 구분하려면, 비어있는 값을 명시적으로 넣을 때는 null을 자바스크립트 엔진이 값을 할당할 수 없거나 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 할당하는 것으로 한다.



---

**퀴즈**

 ``` var object1 = {'a':['b','c',['d','e',['f','g']]]}```  를 복사하려면 재귀함수가 몇 번필요할까? 

```
var copyObectDeep = function(target) {
    var result = {}
    if (typeof target === 'object' && target !== null){
        for(var prop in target){
            result[prop] = copyObectDeep(target[prop])       
         }   
    }else{
        result = target
    }
    return result
}
var object2 = copyObjectDeep(object1)
```
---
--> 10번, 배열의 요소도 각각 실행됨.

(1) object1

(2) ['b','c',['d','e',['f','g']]]

(3) 'b' -> (2)의 prop은 배열의 인데스이기 때문에, target[0]='b'가 됌

(4) 'c'

(5) ['d','e',['f','g']]

(6) 'd'

(7) 'e'

(8) ['f','g']

(9) 'f'

(10) 'g'


![image](https://user-images.githubusercontent.com/76730867/137319809-0f2fb0a3-ceec-4c69-9fa0-11cee3b14ea9.png)

