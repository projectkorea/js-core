# 01 데이터 타입
## 데이터 타입의 종류
자바스크립트의 데이터 타입은 크게 두가지가 있다.
- 기본형
    - 숫자(number)
    - 문자열(string)
    - 불리언(boolean)
    - null
    - undefined
    - 심볼(Symbol) (ES6에서 추가)
- 참조형
    - 객체(object)
    - 배열(array)
    - 함수(function)
    - 날짜(date)
    - 정규표현식(RegExp)
    - Map (아래부터 ES6에서 추가)
    - WeakMap
    - Set
    - WeakSet
    
 **기본형**: 값이 담긴 주솟값을 바로 복제
 **참조형**: 값이 단긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제
  
 ### 식별자와 변수
 - 변수: 변할 수 있는 무언가
 - 식별자: 어떤 데이터를 식별하는데 사용하는 이름 즉 변수명
 
## 변수 선언과 데이터 할당
### 변수 선언
`var a`
"변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다"
변수란 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇

### 데이터 할당
```js
var a //변수 a 선언
a= 'abc' //변수 a에 데이터 할당
```
a라는 이름을 가진 주소를 검색해서 그곳에 'abc'를 할당하면 될 것 같다.
그런데 실제로는 해당 위치에 문자열 'abc'를 직접 정장하지 않는다!
데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 'abc'를 저장하고, 그 주소를 변수 영역에 저장하는 식으로 이뤄진다.

![](https://images.velog.io/images/annie1004619/post/9f61af0a-cadc-4bc3-9e03-c44cf5f69597/KakaoTalk_20211014_182814215.jpg)
1. 변수 영역에서 빈공간(@1003)을 확보한다.
2. 확보한 공간의 식별자를 a로 지정한다.
3. 데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 지정한다.
4. 변수 영역에서 a라는 식별자를 검색한다,(@1003)
5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다.

왜 변수 영역에 값을 직접 대입하지 않고 굳이 한 단계를 더 거칠까??
-> 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위해서!

자바스크립트는 숫자형 데이터에 대해 64비트의 공간을 확보한다. 
반면 문자열은 정해진 규격이 없다. 한 글자마다 영어는 1바이트, 한글은 2바이트 등으로 각각 필요한 메모리 용량이 가변적이며 전체 글자 수 역시 가변적이다.

만약 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 다시 저장하기 위해서는 '확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업'이 선행되어야 한다.

문자열 'abc'의 마지막에 'def'를 추가하라고 하면 컴퓨터는 'abc'가 저장된 공간에 'abcdef'를 할당하는 대신 'abcdef'라는 문자열을 새로 만들어 별도의 공간에 저장하고 그 주소를 변수 공간에 연결한다.

## 기본형 데이터와 참조형 데이터
### 불변값
변수와 상수를 구분하는 성질은 '변경 가능성'이다.
바꿀 수 있으면 변수, 바꿀 수 없으면 상수
- 변수와 상수를 구분 짓는 변경 가능성은 **변수 영역 메모리**
- 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역 메모리**

**불변성 예시**
```js
var a = 'abc'
a = a +'def'

var b = 5
var c = 5
b = 7
```
기존의 'abc'가 바뀌는 것이 아니라 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장
'abc'와 'abcdef'는 완전히 별개의 데이터이다.

데이터 영역에서 5를 찾고 없으면 데이터 공간을 하나 만들어 저장한다.
그 주소를 b에 저장한다.
c에는 이미 만들어놓은 값의 주소를 재활용한다.
변수 b를 7로 바꾸고자 할때 기존에 저장된 5 자체를 7로 바꾸는 것이 아니라 재활용하거나 새로 만들어 b에 그 주소값을 저장한다.
결국 5와 7은 다른 값으로 변경할 수 없다.

```
한번 만든 값은 바꿀 수 없고 변경은 새로 만드는 동작을 통해서만 이뤄진다.
이것이 불변값의 성질
```

### 가변값
참조형 데이터의 할당
(사진)
1. 컴퓨터는 우선 변수 영역의 빈공간(@1002)를 확보하고, 그 주소의 이름을 obj1로 지정한다.
2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(@7103~?)를 @5001에 저장한다.
3. @7103 및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정한다.
4. 데이터 영역에서 숫자 1을 검색한다. 검색 결과가 없으면 임의로 @5004에 저장하고, 이 주소를  @7103에 저장한다.

기본형 데이터와의 차이는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다는 점이다.

참조형 데이터의 프로퍼티 재할당 예시
```js
var obj1 = {
    a: 1,
    b: 'bbb'
}
obj1.a = 2
```
4번째 줄의 명령 전과 후에 변수 obj1이 바라보고 있는 주소는 @5001로 변하지 않았다.
즉 '새로운 객체'가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀐 것이다.

참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 도니다.
가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거한다.

### 변수 복사 비교
```js
var a = 10
var b = a

var obj1 = {C: 10, d: 'ddd'}
var obj2 = obj1

b = 15
obj2.c = 20
```
b에 15를 할당하면 데이터 영역에 15가 없으면 새로운 공간 @5004에 저장하고 그 주소를 가지고 변수 영역에서 식별자가 b인 주소를 찾는다.
원래의 값이 @5004로 변경된다.
obj2.c에 20을 할당하면 데이터 영역에 20이 없으면 새로운 공간 @5005에 저장하고, 그 주소를 가지고 변수 영역에서 obj2를 찾고
obj2 값인 @5002가 가리키는 변수영역에서 다시 c를 찾아(@7103) 그곳에 @5005를 대입한다.

(p.18 사진)

** 객체 자체를 변경했을 때 **
```js
var obj2 = {c:20, d:'ddd'}
```
메모리 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장한다.
객체에 대한 변경임에도 값이 달라진다.

## 불변 객체
참조형 데이터의 '가변'은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립한다.
매번 새로운 객체를 만드는 도구를 활용한다면 객체 역시 불변성을 확보할 수 있다.

불변 객체가 언제 필요할까?
-> 원본 객체는 변하지 않아야 하는 경우

모든 프로퍼티를 복사하는 함수를 만들어 새로운 객체를 만드는 방법
```js
# 얕은 복사
var copyObject = function (target) {
    var result = {}
    for (var prop in target){
        result[prop] = target[prop]    
    }
    return result
}
```

### 얕은 복사와 깊은 복사
- 얕은 복사: 아래 단계의 값만 복사하는 방법
- 깊은 복사: 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법

중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할때 그 주솟값만 복사한다.
```js
var user = {
    name: 'jiwon',
    urls: {
        portfolio: 'aaa',
        blog: 'bbb'
    }   
}
```
즉 user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어지지만
한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조한다.
이러한 현상이 발생하지 않게 하려면 user.urls 프로퍼티에 대해서도 불변 객체로 만들 필요가 있다. 

```js
var users = copyObject(user)
user2.urls = copyObject(user.urls)
```

기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야 한다.

** 객체의 깊은 복사를 수행하는 범용 함수 **
```js
var copyObectDeep = function(target) {
    var result = {}
    if (typeof target === 'object' && target !== null){
        for(var prop in target){
            result[prop] = copyObectDeep(target[prop])       
         }   
    }else{
        result = target
    }
    return result
}
```
target이 객체인 경우에는 내부 프로퍼티들을 순회하며 copyObejctDeep 함수를 재귀적으로 호출하고 객체가 아닌 경우에는 target을 그대로 지정한다.

깊은 복사를 처리할 수 있는 또 다른 방법
객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸기
```js
var copyObectViaJson = function (target) {
    return JSON.parse(JSON.stringify(target))
}
```

## undefined와 null
자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황에 그렇게 하지 않았을 때 undefined를 반환한다.
1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

** undefined와 배열**
```js
var arr1 = []
arr1.length = 3
//[empty * 3]
var arr3 = [undefined, undefined, undefined]
//[undefined, undefined, undefined]
```
이처럼 비어있는 요소와 undefined를 할당한 요소는 출력 결과부터 다르다.
비어있는 요소는 순회와 관련된 배열 메서드들의 순회 대상에서 제외된다.

비어있음을 명시적으로 나타내고 싶을 때는 undefined 대신 null을 쓰면 된다!

```js
var n = null
console.log(typeof n) //object
console.log(n == undefined) // true
console.log(n === undefined) //false
```

---
퀴즈
```
var person = {
    name:'jiwon",
    like: {food: "pasta"}
}
var copyPerson = {...person}
console.log(person === copyPerson}
console.log(person.like === copyPerson.like)
console.log(person.like.food === copyPerson.like.food)
```
