# 03 this

- 자바스크립트에서 가장 혼란스러운 개념이다.
- 다른 객체지향 언어에서의 this
  - 클래스로 생성한 인스턴스 객체를 말한다.
  - this는 클래스에서만 사용할 수 있기 때문에 혼란의 여지가 없다.
- 자바스크립트에서의 this
  - 어디서든 사용할 수 있다. 
  - 상황에 따라 this가 바라보는 대상이 달라진다.
- 특히, 함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다. 
- 이번 단원에서는
  - 상황별로 this가 어떻게 달라지는지,
  - 왜 그렇게 되는지, 
  - 예상과 다른 대상을 바라보고 있을 경우, 그 원인을 효과적으로 추적하는 방법을 살펴보자

---
## 1. 상황에 따라 달라지는 this
  - this는 실행 컨텍스트가 생성될 때 결정된다.
  - 실행 컨텍스트는 함수를 호출할 때 생성된다.
→ **this는 함수를 호출할 때 결정된다.**
→ 함수를 **어떤 방식으로 호출하냐에 따라** 값이 달라진다.

### 1-1 전역 공간에서의 this
- this는 전역 객체를 가리킨다. 
- 전역 컨텍스트를 생성하는 주체가 전역 객체이기 때문이다. 
- 전역 객체는 자바스크립트 런타임 환경에 따라 다르다. 
  ex) window(browser), global(node,js)

  브라우저 전역공간에서의 this
  ```js 
  console.log(this == window) //true
  ```
  Node.js환경의 전역공간에서의 this
  ```js
  console.log(this == global) //true
  ```

  **참고**
  전역 공간에서 발생하는 특이한 성질
  전역변수를 선언하면 JS엔진은 이를 전역객체의 프로퍼티로도 할당한다. 
  ```js
  var a =1
  console.log(a)            // 1
  console.log(this.a)       // 1
  console.log(window.a)     // 1
  ```
  JS의 **모든 변수는 특정 객체의 프로퍼티**로 동작한다.
  특정 객체는 L.E의 프로퍼티로 저장한다.
  이후 어떤 변수를 호출하면 L.E를 조회해서 일치하는 프로퍼가 있을 경우 그 값을 반환한다.
  전역 컨텍스트의 경우 L.E는 전역객체를 그대로 참조한다.

- this.a가 1이 나오는 이유는 알겠는데 a를 직접 호출 해도 1이 나오는 이유는?
→ 변수 a에 접근하고자 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 L.E, 즉 전역객체에서 해당 프로퍼티 a를 발견해서 그 값을 반환하기 때문이다.  
→ window가 생략된 것이라고 이해했던 원리는 이렇다.

<br>

```js
var a = 1
window.b = 2
console.log(a, window.a, this.a)   // 1 1 1
console.log(b, window.b, this.b)   // 2 2 2

window.a =  3
b = 4
console.log(a, window.a, this.a)   // 3 3 3
console.log(b, window.b, this.b)   // 4 4 4
```
→ 전역 공간에서 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당하더라도 같은 동작을 한다.

<br>

**삭제 명령**
```js
var a = 1
delete window.a
console.log(a, window.a, this.a)   // 1 1 1

var b = 2
delete b
console.log(b, window.b, this.b)   // 2 2 2

window.c =  3
delete window.c
console.log(c, window.c, this.c)   // Uncaught ReferenceError: c is not defined

window.d =  4
delete d
console.log(d, window.d, this.d)   // Uncaught ReferenceError: d is not defined
```
→ 처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 된다.
→ 하지만 전역변수 선언한 경우에는 삭제가 되지 않는다.
→ 이는 사용자가 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 방어 전략이다. 
→ 즉, 전역변수를 선언하면 JS 엔진이 자동으로 전역객체의 프로퍼티로 할당하면서, 추가적으로 해당 프로퍼티의 configurable속성을 false로 정의한다. 
configurable 속성(변경 및 삭제 가능성)
→ 이처럼 var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable 여부에서 차이를 보인다.



### 1-2 메서드로서 호출할 때 그 메서드 내부에서의 this
**함수 vs 메서드**
- 어떤 함수를 실행하는 가장 일반적인 방법 두 가지는 
  - 함수로서 호출하는 경우와
  - 메서드로서 호출하는 경우이다.
- 이 둘을 구분하는 유일한 차이는 독립성이다.
- 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다.

JS초보들은 메서드를 '객체의 프로퍼티에 할당된 함수'로 이해하곤 한다.
어떤 함수를 객체의 프로퍼티에 할당한다고해서 무조건 메서드가 되는 것이 아니다.
객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 아니면 함수로 동작한다.

```js
var func = function (x) {
    console.log(this, x)
}
func(1)        // window { ...} 1

var obj = {
    method: func
}
obj.method(2)  // { method: f } 2
```
→ 원래의 익명함수는 그대로인데, 이를 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라진다. 
→ 그렇다면 '함수로서 호출'과 '메서드로서 호출'은 어떻게 구분하나? 

```js
var obj = {
    method: function(x) {
        consoe.log(this,x)
    }
}
obj.method(1) // {method: f } 1
obj['mehtod'] // {method: f } 2
```
간단하다.
'점 표기법' 또는 '대괄호 표기법'과 같이 함수 이름 앞에 객체가 명시돼 있는 경우 메스도로 호출한 것이다.

**메서드 내부에서의 this**

```js
var obj = {
    methodA: function () { console.log(this) }
    inner: {
        methodB: function (){ console.log(this) }
    }
}
obj.methodA()             // { methodA: f, inner: {...} } ( ===obj)
obj['methodA']()          // { methodA: f, inner: {...} } ( ===obj)

obj.inner.methodB()       // { methodB: f }  ( ===obj.inner)
obj.inner['methodB']()    // { methodB: f }  ( ===obj.inner)
obj.['inner'].methodB()   // { methodB: f }  ( ===obj.inner)
obj.['inner']['methodB']  // { methodB: f }  ( ===obj.inner)
```
- this에는 호출한 주체에 대한 정보가 담긴다.
- 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체이다.
- 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this가 된다.



### 1-3 함수로서 호출할 때 그 함수 내부에서의 this

#### 함수 내부에서의 this
어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않는다.
this에는 호출한 주체에 대한 정보가 담긴다.
객체지향 언어에서는 함수로서 호출하는 것은 호출 주체를 명시하지 않고 개발자가 코드에 직접 관여하여 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다.
실행 컨텍스트를 활성화할 당시에 this가 지정되지 않은 경우 this는 전역 객체를 바라본다. 
따라서 함수에서의 this는 전역객체를 가리킨다. 
이는 설계상의 오류이다. 

#### 메서드 내부함수에서의 this
메서드 내부에서 정의하고 실행한 함수에서의 this가 가장 혼란스러운 지점이다.
설계상의 오류 때문이다. 설계상의 오류는 실제 동작과 다르게 예측될 때를 말한다.
this라는 단어 자체가 주는 느낌 그대로 코드를 바라모면 예상과 다른 결과가 나온다. 

### 1-4 콜백 함수 호출 시 그 함수 내부에서의 this
함수의 A의 제어권을 다른 함수 또는 메서드 B에게 넘겨주는 경우,
함수 A를 콜백함수 라고 한다. 
함수 A는 함수 B의 내부 로직에 따라 실행되며, this역시 함수 B내부 로직에서 정한 규칙에 따라 값이 결정된다.
콜백 함수도 함수이기 때문에 1-3과 마찬가지로 this가 전역객체를 참조하지만, 제어권을 받은 함수에서 콜백함수에 별도로 this가 될 대상을 지정한 경우 그 대상을 참조한다. 

### 1-5 생성자 함수 내부에서의 this
생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용되는 함수다. 
객체지향 언어에서는 생성자를 클래스, 클래스를 통해 만드는 객체를 인스턴스라고 한다. 
생성자는 구체적인 인스턴스를 만들기 위한 일종의 틀이다. 
이 틀에는 해당 클래스의 공통 속성들이 미리 준비돼있고, 여기에 구체적인 인스턴스의 개성을 더해 개별 인스턴스를 만들 수 있다.

자바스크립트는 함수에 생성자로서의 역할을 함께 부여했다.
new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작한다.
어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 된다. 

생성자 함수를 호출하면 우선 생성장의 prototype프로퍼티를 참조하는 __proto__라는 프로퍼티가 있는 객체를 만든다.
미리 준비된 공통 속성 및 개성을 해당 객체에 부여한다.
이렇게 해서 구체적인 인스턴스가 만들어진다.

## 2. 명시적으로 this를 바인딩하는 방법
상황별로 this에 어떤 값이 바인딩되는지 살펴보았다.
하지만 이런 규칙을 깨고 this에 별도의 대상을 바인딩 하는 방법도 있다.

### 2-1 call 메서드
```js
Function.prototype.call(thisArg[,arg1[,arg2[,...]]])
```

call메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령이다. 
이때 call메서드의 첫 번째 인자를 this로 바인딩한다.
이후의 인자들을 호출할 함수의 배개변수로 한다.
함수를 그냥 실행하면 this는 전역객체를 참조하지만 call메서드를 이용하면 임이의 객체를 this로 지정할 수 있다.

**call 메서드 예제1**
**call 메서드 예제2**


### 2-2 apply 메서드
```js
Function.prototype.apply(thisArg[,argsArray])
```
apply 메서드는 call메서드와 기능적으로 완전히 동일하다.
call메서드는 첫 번째 인자를 제외한 나머지 모든 인자들을 호출할 함수의 메개변수로 지정한다.
반면, apply메서드는 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다.




### 2-3 call/apply 메서드 활용


### 2-4 bind 메서드
```js
Function.prototype.bind(thisArg[, arg1[,arg2[, ...]]])
```
bind 메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드이다.
다시 새로운 함수를 호출할 때 인수를 넘기면 그 인수들은 기존 bind 메서드를 호출할 때 전달했던 인수들의 뒤에 이어서 등록된다. 
즉, bind메서드는 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닌다. 

### 2-5 화살표 함수의 예외사항
ES6에 새롭게 도입된 화살표 함수는 실행 컨텍스트 생성 시 this를 바인딩하는 과정이 제외됐다. 
이 함수 내부에는 this가 아예 없으며, 접근하고자 하면 스코프체인상 가장 가까운 this에 접근하게 된다.

### 2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)
콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체(thisArg)를 인자로 지장할 수 있는 경우가 있다.
이런 메서드의 thisArg 값을 지정하면 콜백 함수 내부에서 this값을 원하는 대로 변경할 수 있다.
이런 형태는 여러 내부 요소에 대해 같은 동작을 반복 수행해야 하는 배열 메서드에 많이 포진돼 있으며, 같은 이유로 ES6에서 새로 등장한 Set, Map 등의 메서드에서도 일부 존재한다. 

## 정리

- 전역공간에서의 this는 전역객체를 참조한다.
→ 브라우저에서는 window, Node.js에서는 global
- 어떤 함수를 메서드로서 호출한 경우 this는 메서드 호출 주체를 참조한다. 
→ 메서드 호출 주체: 메서드명 앞의 객체
- 어떤 함수를 함수로서 호출한 경우 this는 전역객체를 참조한다. 메서드의 내부함수에서도 같다.
- 콜백 함수 내부에서의 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며, 정의하지 않은 경우에는 전역객체를 참조한다.
- 생성자 함수에서의 this는 생성될 인스턴스를 참조한다. 

다음은 명시적 this 바인딩 규칙이다. 위의 규칙에 부합하지 않은 경우 아래를 보고 this를 예측할 수 있다.
- call, apply 메서드는 this를 명시적으로 지정하면서 함수 또는 메서드를 호출한다.
- bind메서드는 this 및 함수에 넘길 인수를 일부 지정해서 새로운 함수를 만든다. 
- 요소를 순회하면서 콜백 함수를 반복 호출하는 내용의 일부 메서드는 별도의 인자로 this를 받기도 한다.





















